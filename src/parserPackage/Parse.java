package parserPackage;

import java.io.FileOutputStream;
import java.io.IOException;

import lexicalAnalyzerPackage.*;

public class Parse {
	
	public LexicalAnalyzer LA = null; // we need a lexical analyzer so we can grab tokens
	tokenCodes nextToken = null;
	FileOutputStream writer;
	String output = "";
	
	public Parse(LexicalAnalyzer lexical_analyzer) {
		LA = lexical_analyzer;
		output+="****************************************************\nTrevor H. Crow, CSCI4200, Fall 2019, Parser\n****************************************************\n";
	}
	
	/*
	 * assign
	 * <assign> -> = <expr>
	 */
	public void assign() {
		// we want to repeat assign for however many inputs we had
		for(int i = 0; i<LA.getInputs().size();i++) {
			output+="Parsing the statement: "+LA.getInputs().get(i)+"\n";
			lex();
			output+="Enter <assign>"+"\n";
			if(nextToken == tokenCodes.IDENT) {
				lex();
				if(nextToken == tokenCodes.ASSIGN_OP) {
					lex();
					expr();
				}
			}
			output+="Exit <assign>"+"\n";
		}
		output+="END_OF_FILE"+"\n";
		/*
		 * 		else {
			
			if(nextToken == tokenCodes.END_OF_LINE) ;
			else System.out.println("END_OF_FILE"); //we're now at the end of the file
		}
		 */
	}
	
	/*
	 * expr
	 * Parses strings in the language generated by the rule:
	 * <expr> -> <term> {(+ | -) <term>}
	 */
	private void expr() {
		output+="Enter <expr>"+"\n";
		
		// parse the first term
		term();
		
		// as long as the next token is + or -, get the next token and parse the next term
		while (nextToken == tokenCodes.ADD_OP || nextToken == tokenCodes.SUB_OP) {
			lex();
			term();
		}
		output+="Exit <expr>"+"\n";
	}
	
	/*
	 * term
	 * Parses strings in the language generated by the rule:
	 * <term> -> <factor> {(* | /) <factor>}
	 */
	private void term() {
		output+="Enter <term>"+"\n";
		
		// parse the first factor
		factor();
		
		while(nextToken == tokenCodes.MULT_OP || nextToken == tokenCodes.DIV_OP) {
			lex();
			factor();
		}
		
		output+="Exit <term>"+"\n";
	}
	
	/*
	 * factor
	 * Parses strings in the language generated by the rule:
	 * <factor> -> id | int_constant | (<expr>)
	 */
	private void factor() {
		output+="Enter <factor>"+"\n";
		
		// determine which is RHS
		if(nextToken == tokenCodes.IDENT || nextToken == tokenCodes.INT_LIT) lex(); // get the next token
		
		// if the RHS is (<expr>), call lex to pass over the left parenthesis, call expr, and check for the right parenthesis
		else {
			if(nextToken == tokenCodes.LEFT_PAREN) {
				lex();
				expr();
				if(nextToken == tokenCodes.RIGHT_PAREN) lex();
				else error();
			}else if(nextToken == tokenCodes.ASSIGN_OP) lex();
			else error(); // it was not an id, an integer literal, or a left parenthesis
		}
		
		output+="Exit <factor>"+"\n";
	}
	
	// print out error message saying which token the error occured at
	private void error() {
		output+="Error occured on token: "+nextToken+"\n";
	}
	
	// pops nextToken from token_list
	private void lex() {
		nextToken = LA.getTokenList().poll();
		if(nextToken != tokenCodes.END_OF_LINE && nextToken != tokenCodes.END_OF_FILE) output+="Next Token is: "+nextToken+"\n";
	}
	
	//writes the output to a file
	public void output() throws IOException {
		System.out.println(output);
		writer = new FileOutputStream("parseOut.txt");
		writer.write(output.getBytes());
		writer.close();
	}
}
